import { Meta, Source } from '@storybook/addon-docs';
import { MyCustomElement } from './styling/MyCustomElement';
import { ThemeProvider, MessageStrip } from '@ui5/webcomponents-react';
import { BarComponent, FaultyBarComponent } from './knowledgeBaseExamples/slotExamples';
import { CreateAccountForm } from './knowledgeBaseExamples/formExamples';
import { TableOfContent } from '../.storybook/components/TableOfContent';
import { Footer } from '@docs/Footer';

<Meta title="Knowledge Base" />

# Knowledge Base

This section is a collection of special use cases that might be encountered when working with UI5 Web Components for React.

<TableOfContent />

<br />

## Test Setup

This guide is applicable if you are using a standard `create-react-app` setup.

`create-react-app` offers you to modify specific parts of the `jest` config by adding `jest` object to your `package.json`.
Here you need to tell `jest` to transpile the UI5 Web Components as well as the `lit-html` library:<br />
`package.json:`

```json
{
  "jest": {
    "transformIgnorePatterns": ["node_modules/(?!(@ui5|lit-html)).*\\.js$"]
  }
}
```

Since the UI5 Web Components and UI5 Web Components for React are based on the `ResizeObserver`, `IntersectionObserver`, `fetch` and `matchMedia` API, you'll need to polyfill all of them.
Therefore, create (or edit) your `src/setupTests.js` file as follows:

```js
import ResizeObserverPolyfill from 'resize-observer-polyfill';
import 'intersection-observer';
import 'whatwg-fetch';

const setupMatchMedia = () => {
  Object.defineProperty(window, 'matchMedia', {
    writable: true,
    value: jest.fn().mockImplementation((query) => {
      const maxWidth = parseInt(/max-width:(?<maxWidth>\d+)px/.exec(query)?.groups?.maxWidth);
      const minWidth = parseInt(/min-width:(?<minWidth>\d+)px/.exec(query)?.groups?.minWidth);

      let matches =
        (minWidth ? minWidth <= window.innerWidth : true) && (maxWidth ? window.innerWidth <= maxWidth : true);

      if (query === '(orientation: landscape)') {
        matches = window.innerWidth > window.innerHeight;
      }

      return {
        matches,
        media: query,
        onchange: null,
        addListener: jest.fn(), // deprecated
        removeListener: jest.fn(), // deprecated
        addEventListener: jest.fn(),
        removeEventListener: jest.fn(),
        dispatchEvent: jest.fn()
      };
    })
  });
};

beforeEach(() => {
  Object.defineProperty(globalThis, 'crypto', {
    value: {
      randomUUID: () => '1'
    }
  });
  setupMatchMedia();
  window.ResizeObserver = ResizeObserverPolyfill;
});
```

<MessageStrip hideCloseButton>
  Please note that you must also wrap your components in the `ThemeProvider` component for testing, otherwise components
  with translations will probably not render.
</MessageStrip>

Now you should be able to run your test by using `npm run test` or `yarn test`.

<br />

## Adding custom components to slots

With our wrapper we provide an easy way to consume the `slots` of the UI5 Web Components by attaching them to a `prop`.
In most cases you don't have to take anything into account, and the props can be used in a typical React way. However, there is an exception with custom components:

```jsx
const BarStart = () => {
  return <div>Start</div>;
};
const BarEnd = () => {
  return <Button>Close</Button>;
};
export const BarComponent = () => {
  return (
    <Bar startContent={<BarStart />} endContent={<BarEnd />}>
      <div>I'm not a custom component</div>
    </Bar>
  );
};
```

The `BarComponent` would compile to this:

<FaultyBarComponent />

As you can see, both custom components are not displayed.
Our wrapper does add the `slot` prop to the custom component, but the most outer HTML-Element/component (e.g. `<div>Start</div>`) does not accept it and therefore cannot use it.

To fix this the `slot` prop must also be passed to the outer element of the component:

```jsx
const BarStart = (props) => {
  return <div slot={props.slot}>Start</div>;
};
const BarEnd = (props) => {
  return <Button slot={props.slot}>Close</Button>;
};
export const BarComponent = () => {
  return (
    <Bar startContent={<BarStart />} endContent={<BarEnd />}>
      <div>I'm not a custom component</div>
    </Bar>
  );
};
```

Now the `BarComponent` would compile to this:

<BarComponent />

<br />

## Styling

You can easily change the appearance of the Web Components by using [CSS Variables](https://www.w3schools.com/Css/css3_variables.asp).
Per default, we are injecting the Fiori 3 theme parameters as CSS Variables into the `<head>`.
If you want to change the color of all texts, you can do that by creating another `style` tag with the following content:

```html
<style>
  :root {
    --sapTextColor: limegreen;
  }
</style>
```

As a consequence, all HTML Elements in the subtree where this style was applied are now displaying their texts in `limegreen` instead of `#32363a` which would be the default value for Fiori 3.
You can change CSS Variables on any level - in the head, or on every single element by using either CSS classes or element style.

A full list of all supported CSS Variables can be found [here](https://github.com/SAP/ui5-webcomponents-react/blob/main/packages/base/src/styling/ThemingParameters.ts)
or in the [SAPUI5 Theming Parameters Toolbox](https://sapui5.hana.ondemand.com/test-resources/sap/m/demokit/theming/webapp/index.html).

### Reuse global style classes

The `ThemeProvider` component is offering global css classes that can be reused in your applications code to help you to achieve a Fiori look-and-feel.
All globally available style classes are tracked in the `GlobalStyleClasses` enum which can be imported from `import { GlobalStyleClasses } from "@ui5/webcomponents-react/dist/GlobalStyleClasses";`.

| CSS Class      | Description                                                                                                       |
| -------------- | ----------------------------------------------------------------------------------------------------------------- |
| `sapScrollBar` | If added to an container that supports scrolling, the scrollbar will be styled according to the Fiori guidelines. |

#### Use default browser scrollbar

Some components like the `ObjectPage`, `DynamicPage` and `AnalyticalTable` use the CSS class `sapScrollBar` by default. To prevent these components from using the custom scrollbar, you can pass `data-native-scrollbar` as prop.

### Style your own components

It's quite likely that you have to create some custom components when you are building an app.
In order to reuse our central styling approach, you can import the `ThemingParameters` that contain the various CSS variables used in our theming.
If you want to style your components with the `react-jss` syntax, you can use our custom `jss` styling hook.

`react-jss` comes already as a dependency of `@ui5/webcomponents-react` to your project - but we recommend adding it to your `package.json` as well.
**Please make sure you are installing `"react-jss": "^10.0.0"`**. Previous versions of this library won't work correctly together with our library.

You can then create a custom component by following this recipe:

```jsx
import React from 'react';
import { createUseStyles } from 'react-jss';
import { ThemingParameters } from '@ui5/webcomponents-react-base';

const styles = {
  container: {
    backgroundColor: ThemingParameters.sapBackgroundColor,
    fontFamily: ThemingParameters.sapFontFamily,
    height: '50px',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center'
  }
};

const useStyles = createUseStyles(styles, { name: 'MyCustomElement' });

const MyCustomElement = () => {
  const classes = useStyles();
  return (
    <div className={classes.container}>
      <span style={{ color: ThemingParameters.sapNegativeColor, fontSize: ThemingParameters.sapFontLargeSize }}>
        My Text
      </span>
    </div>
  );
};
```

This would then be the result:

<ThemeProvider>
  <MyCustomElement />
</ThemeProvider>

## Form Handling

This guide demonstrates the use of the `Form` component.

### #1 Example with UI5 Web Components for React

This Form is implemented with the `Form` component from UI5 Web Components for React.
The children of the `Form` should only be `FormGroup` and `FormItem` in order to preserve the intended design. The children of `FormGroup` should only be `FormItem` and the children of `FormItem` can be an arbitrary React Node.

You can then create a form with UI5 Web Components for React as follows. Also you can find this example in a Codesandbox. [![Edit wcr form](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/wcr-form-5f9c24?fontsize=14&hidenavigation=1&theme=dark)

<details>
    <summary>Show code</summary>

```jsx
import React, { useState } from 'react';
import {
  ThemeProvider,
  Form,
  FormGroup,
  FormItem,
  Input,
  Option,
  Select,
  CheckBox,
  InputType,
  Button,
  MultiComboBox,
  MultiComboBoxItem,
  DatePicker
} from '@ui5/webcomponents-react';
import '@ui5/webcomponents/dist/features/InputElementsFormSupport.js';

export default function CreateAccountForm() {
  const initialValues = {
    email: '',
    password: '',
    country: 'Germany',
    birthday: '',
    payment: [],
    terms: false
  };

  const [values, setValues] = useState(initialValues);

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setValues({
      ...values,
      [name]: value
    });
  };

  const handleSelectionChange = (e) => {
    const selected = [];
    Object.entries(e.detail.items).forEach(([key, val]) => {
      selected.push(val.text);
    });
    setValues({
      ...values,
      payment: selected
    });
  };

  const handleSubmit = (e) => {
    alert(JSON.stringify(values, null, 2));
    console.log(values);
  };

  return (
    <ThemeProvider>
      <Form>
        <FormGroup titleText={'Create Account'}>
          <FormItem label={'Email'}>
            <Input name="email" type={InputType.Email} value={values.email} onInput={handleInputChange} />
          </FormItem>
          <FormItem label={'Password'}>
            <Input name="password" type={InputType.Password} value={values.password} onInput={handleInputChange} />
          </FormItem>
          <FormItem label={'Country'}>
            <Select
              name="country"
              value={values.country}
              onChange={(e) =>
                setValues({
                  ...values,
                  country: e.detail.selectedOption.innerText
                })
              }
            >
              <Option>Germany</Option>
              <Option>France</Option>
              <Option>Italy</Option>
            </Select>
          </FormItem>
          <FormItem label={'Date of Birth'}>
            <DatePicker
              value={values.birthday}
              onChange={(e) => {
                setValues({
                  ...values,
                  birthday: e.detail.value
                });
              }}
            />
          </FormItem>
          <FormItem label={'Payment methods'}>
            <MultiComboBox onSelectionChange={handleSelectionChange}>
              <MultiComboBoxItem text="Credit card" />
              <MultiComboBoxItem text="PayPal" />
              <MultiComboBoxItem text="Bank transfer" />
            </MultiComboBox>
          </FormItem>
          <FormItem>
            <CheckBox
              required
              name="terms"
              text="I accept the terms of service"
              value={values.terms}
              onChange={(e) =>
                setValues({
                  ...values,
                  terms: e.target.checked
                })
              }
            />
          </FormItem>
          <FormItem>
            <Button onClick={handleSubmit}>Submit</Button>
          </FormItem>
        </FormGroup>
      </Form>
    </ThemeProvider>
  );
}
```

</details>

Now the `AccountForm` would compile to this:

<CreateAccountForm />

Note: Whenever a component has a custom event (e.g. onChange event from `DatePicker`), the corresponding value should be fetched via event.detail (not event.target). This will give you the correct updated value since the internal input has already been updated. At the time the event is fired, however, it is not yet updated and therefore event.target might also not be updated yet.

### #2 Example with UI5 Web Components for React and Formik + Yup

Input components from UI5 Web Components for React can be used with external libraries like Formik and Yup.
Formik is an open source form library for React and React Native (https://formik.org/).
Yup is a schema builder for runtime value parsing and validation (https://github.com/jquense/yup).

Formik keeps track of your form's state and then exposes it plus a few reusable methods and event handlers (handleChange, handleBlur, and handleSubmit) to your form via props
It comes with a few extra components to make life easier and less verbose like `Form`, `Field`, and `ErrorMessage`.
Also Formik has a special config option for Yup called validationSchema.

To inject an input component from UI5 Web Components for React the `Field` component has a prop called `as`.
This can either be a React component or the name of an HTML element to render. Formik will automagically inject onChange, onBlur, name, and value props of the field designated by the name prop to the (custom) component.

```jsx
<Field as={Input} />
```

You can find a Codesandbox that will showcase the use of the input components from UI5 Web Components for React together with Formik and Yup.
[![Edit formik + wcr form](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/formik-wcr-form-bt7jd2?autoresize=1&fontsize=14&hidenavigation=1&theme=dark)

Note: The onChange event from the `Input` UI5 Web Component is not the same as the native onChange event of React. If you want to simulate that behavior, please use onInput instead.
onChange here: This event is NOT the same as the native onChange event of React. If you want to simulate that behavior, please use onInput instead.

```jsx
<Field as={Input} name="email" type={InputType.Email} onInput={formik.handleChange} />
```

<Footer />
